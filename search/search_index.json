{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ROXBOT - a Pythonic robotics toolkit","text":""},{"location":"#what-is-this","title":"What is this?","text":"<p>Project <code>roxbot</code> is a handbook for robotcs developers. It is intended as a knowledge base, providing a series of examples, reusable library code and tips and tricks for building robotic systems. Common use case is an AGV, navigating with an RTK-GPS module.</p>"},{"location":"#project-roadmap","title":"Project roadmap","text":"<p>see roadmap discussion</p> <p>Note: watch this repository to be notified about updates. (we don't do spammy mailing lists)</p>"},{"location":"#quick-start","title":"Quick start","text":"<ul> <li>documentation</li> <li>read the blog</li> <li>join discussion</li> <li>join the project!</li> </ul>"},{"location":"#what-about-ros","title":"What about ROS?","text":"<p>Well, ROS2 has some nice concepts, but it can be complex and complicated. Besides, ROS is C++ centric, which makes it a bit old-fashioned. Another shortcoming is a large codebase that has not been widely tried and tested in real world applications.</p>"},{"location":"#key-principles","title":"Key principles","text":"<ul> <li>KISS (keep it simple, stupid): - let's make robotics easier by reducing complexity.</li> <li>Less Code Equals Fewer Problems: - keep codebase small and portable. \"Code is not an asset but a liability\"</li> <li>Don't reinvent the wheel - leverage robust existing technologies. Think of <code>asyncio</code>, <code>Docker</code> etc.</li> </ul>"},{"location":"#concepts","title":"Concepts","text":"<p>ROXBOT takes familiar ideas from ROS2 and makes them easier to use and more Python-friendly:</p> <ul> <li> <p>Nodes: These are small, focused classes that perform specific tasks within the robotics application. For example, one Node might manage sensor data while another controls a motor.</p> </li> <li> <p>Interfaces: These are standardized formats that ensure consistent data exchange between Nodes. This makes it easy for different parts of your project to communicate and work together effectively.</p> </li> <li> <p>Subsystems: This term refers to a group of Nodes that work together to perform a broader function like motion control or data logging. These subsystems can be packaged into Docker containers for easy deployment and scaling.</p> </li> <li> <p>System: This is the complete set of subsystems working together as a whole, forming a fully functional robotic system. We manage these as a Docker stack to ensure they are robust and scalable.</p> </li> </ul>"},{"location":"#classes-overview","title":"Classes overview","text":"<p>images are found in <code>docs/uml</code></p> <p>run <code>invoke uml</code> to update.</p>"},{"location":"code_reference/","title":"Code reference","text":""},{"location":"code_reference/#classes-overview","title":"Classes overview","text":""},{"location":"code_reference/#reference","title":"Reference","text":"<ul> <li>roxbot.interfaces</li> <li>roxbot.bridges</li> </ul>"},{"location":"contributing/","title":"Contributing","text":""},{"location":"contributing/#how-to-contribute","title":"How to contribute","text":"<p>This is what you can do to make this project a succes:</p> <ul> <li>Star the github repo - this promotes its visibility</li> <li>Join the discussion on the forum - we'd love to know how we can make robotics development easier.</li> <li>Find something worth fixing? Submit an issue.</li> <li>Write a blog post or add to documentation by creating a pull request.</li> </ul>"},{"location":"contributing/#development-workflow","title":"Development workflow","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>VSCode with devcontainer extension intalled</li> <li><code>invoke</code> - python automation tool (<code>pip install invoke</code>)</li> <li><code>docker</code></li> </ul>"},{"location":"contributing/#working-in-devcontainer","title":"Working in devcontainer","text":"<p>This repository provides a <code>.devcontainer</code> environment that can be used in VSCode. For more information, read VSCode containers docs</p> <p>The source for devcontainer image is located in <code>docker/dev</code>. It is built by github actions and hosted at <code>ghcr.io/rox-automation/roxbot:latest</code></p>"},{"location":"contributing/#ci","title":"CI","text":"<p><code>ci_script.sh</code> executes linting and testing steps. This script can be run from a devcontainer or in a CI environment. CI can be run in these ways:</p> <ul> <li>on host machine, run <code>invoke ci</code>. This will build a CI docker container, copy source code into it an run it. Because of caching, this is the fastest way to run ci in a clean envirionment.</li> <li>in devcontainer run <code>./ci_script.sh</code>.</li> <li>automated CI with github actions: TODO</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/2023/11/20/plotting-live-data-with-plotjuggler/","title":"Plotting live data with Plotjuggler","text":"<p>Containerization is crucial for a reliable CI/CD workflow, but it can be challenging when you need live data visualization, especially for things like tuning motion control.</p> <p>The good news? There's a simple solution. Just send your data to Plotjuggler using a UDP socket. I've included a code example below to show you how it's done. It's straightforward yet still packs in all the features you need for real-time signal visualisation.</p> <p>Need to stream data quickly? Just use the UDP_Client from the example. With just a few lines of code, you're all set.</p> <p>Note</p> <p>This approach of using udp packets is great when you have a single container application and no messaging layer setup. If messaging middleware is being used, like <code>mqtt</code> for example, it is better to use mqtt messages in order to avoid functionality duplication. Plotjuggler is capable of handling <code>mqtt</code> and <code>ROS</code> messages.</p> <p></p> <pre><code>\n</code></pre>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/","title":"Why asyncio is Ideal for Robotics Development","text":"<p>As a professional in robotics software development, I've extensively used ROS. In fact, ROS2 is the current standard in this field. However, I've recently transitioned to using asyncio, a leaner solution that allows for the creation of more efficient and manageable codebases in a shorter time. In this post, I'll share my experiences with ROS and explain why I believe asyncio is a superior choice.</p> <p></p>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#ros-in-a-nutshell","title":"ROS In A Nutshell","text":"<p>Let's start with a brief introduction to ROS for those unfamiliar with it. Essentially, ROS (Robot Operating System) is a framework designed to help in creating and managing asynchronous processes, known as \"nodes\". These nodes are individual processes tasked with specific functions, like reading a sensor or controlling an actuator. They communicate through \"topics\" using a publish/subscribe pattern, and request/reply interactions are facilitated through services. In this article, when I refer to \"ROS\", I'm specifically talking about ROS2, as ROS1 is now outdated and not recommended for industrial use.</p>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#why-ros-might-not-be-the-ideal-choice","title":"Why ROS Might Not Be the Ideal Choice","text":"<p>While ROS is quite helpful in managing complex, asynchronous systems, I often found it to be somewhat cumbersome, adding unnecessary complexity and slowing down development, especially when compared to more streamlined frameworks available in the Python ecosystem.</p> <p>Here are some key limitations I encountered with ROS, particularly from a Python developer's perspective:</p> <ol> <li>Primary Language: ROS primarily uses C++, making Python integration feel like an afterthought. The Python library <code>rclpy</code> often lacks the full functionality of its C++ counterpart.</li> <li>Packaging and Execution Process: The way ROS packages and executes code is quite different from standard Python practices. For example, why do we need to source a setup file (<code>source /setup.bash</code>) and then use a ROS-specific command (<code>ros2 run ...</code>) when we could just run an executable directly?</li> <li>Launch System: ROS employs its own unique and complex and inefficient launch system (each <code>launch.py</code> file consuming around 20MB of memory). In contrast, tools like <code>systemd</code> and Docker provide more mature and well-designed launching solutions for modern applications.</li> <li>Interface Definitions: The process of defining and compiling interfaces in ROS can add unnecessary overhead to development.</li> <li>Cross-Domain Communication: Transferring data across different subdomains in ROS can be challenging. An alternative like MQTT, with its centralized protocol, simplifies this process by specifying clear host and port connections, making troubleshooting more straightforward.</li> <li>Performance Issues: Inter-node communication, especially between nodes written in Python, can be inefficient, leading to sluggish performance. I'll delve more into this in the \"Benchmarks\" section.</li> <li>Native graphics requirement: ROS relies on tools like RQT, which depend on native graphics. This setup becomes problematic when working remotely, as these tools are not easily accessible or functional across network domains. A more practical alternative would be web-based tools, which can be operated from any browser, offering greater flexibility and ease of use in remote working scenarios.</li> </ol>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#introducing-roxbot-a-pythonic-ros-alternative","title":"Introducing Roxbot: A Pythonic ROS Alternative","text":"<p>Confronted daily with these challenges in ROS, I was motivated to find solutions to streamline my work. Over the past year, I've been developing a Python-centric robotics framework named \"Roxbot\". This framework is akin to ROS but is designed to overcome the limitations I've encountered. Currently, Roxbot is in its pre-release phase and can be explored on Github Note that while Roxbot is not ready for release as a full-fledged ROS replacement, it contains many bits and pieces that I've been using in various customer projects over the course of last year.</p> <p>While I plan to delve deeper into Roxbot in a future post, this article will focus on its most critical component \u2013 the communication layer. Selecting the right communication protocol is perhaps the most significant and challenging architectural decision in the framework's development. To ensure I made an informed choice, I created an extensive benchmark suite. This suite evaluates various communication protocols, examining their performance both within and across Docker containers. I will share the comprehensive findings and insights from this benchmarking in the next section of the blog.</p>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#benchmarks-the-results-are-in","title":"Benchmarks: The Results Are In!","text":"<p>The complete benchmark suite is accessible on GitLab in the <code>messaging</code> folder.</p> <p>The benchmark involves various scenarios with nodes named <code>Alice</code> and <code>Bob</code> communicating within the same Docker container or across two different ones. Here's a brief overview:</p> <ul> <li>ROS Benchmark Python: Two <code>rclpy</code> nodes in the same container.</li> <li>C++ in Single Container: Two C++ nodes in the same container.</li> <li>C++ in Two Containers: Separate containers, communicating over the host network.</li> <li>C++ in Two Isolated Containers: Separate containers, communicating over an isolated Docker network.</li> <li>MQTT Benchmark: Separate containers using <code>paho.mqtt</code> with a Mosquitto broker, over an isolated Docker network.</li> <li>Async Benchmark: Same container, nodes communicate via <code>asyncio.Queue</code>.</li> <li>Websocket Benchmark: Separate containers, nodes communicate using <code>websockets</code>.</li> <li>RPC Benchmark:  <code>grpc</code> remote call. Note that this is different from other methods as it uses request/reply instead of pub/sub</li> </ul>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#benchmark-methodology","title":"Benchmark Methodology:","text":"<ol> <li>Alice sends the number 0 to Bob.</li> <li>Bob increments the number to 1 and sends it back to Alice.</li> <li>Alice increments it to 2 and sends it back to Bob.</li> <li>This ping-pong continues until a specific count is reached (typically 10,000).</li> <li>The \"message rate\" is calculated based on the number of messages exchanged per second.</li> </ol> <p>These benchmarks are designed to run in Docker containers, allowing for easy replication on your system. For detailed instructions, refer to the <code>README.md</code> file.</p>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#and-the-winner-is","title":"And The Winner Is...","text":"<p>After running the benchmark suite on various systems, the insights gained were quite eye-opening. Here's what emerged:</p> <ol> <li>Python nodes in ROS exhibit significantly slow communication speeds.</li> <li>C++ nodes offer decent performance, but C++ may not be the preferred language for ease of coding.</li> <li>Python <code>async</code> stands out remarkably, surpassing even C++ systems in single-container setups by a substantial margin.</li> </ol> <p>An interesting observation was the performance drop in ROS C++ nodes when communicating across containers in an isolated Docker network. Therefore, if you're considering segmenting your system into separate Docker containers, using <code>net=host</code> might be a more efficient approach.</p> <p>Top of this post contains results from a fairly modern laptop with an i5 processor. Tests on a RaspberryPi 4 with 2GB of memory produce these results:</p> <p></p> <p>While the difference in perofmance between C++ and asyncio on <code>aarch64</code> is less dramatic than on a <code>x86_64</code>system, asyncio is an undisputed winner here.</p>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#show-me-the-code","title":"Show Me The Code!","text":"<p>Info</p> <p>The complete benchmark suite is accessible on GitLab in the <code>messaging</code> folder.</p> <p>Another great advantage of <code>asyncio</code> is code simplicity. An implementation of <code>EchoNode</code> looks like this:</p> <pre><code>STOP_AFTER = 100_000\n\nclass EchoNode:\n    def __init__(self, name: str, sub_q: asyncio.Queue, pub_q: asyncio.Queue):\n        self.name = name\n        self.sub_q = sub_q\n        self.pub_q = pub_q\n\n        # Alice starts the ping-pong\n        if name.lower() == \"alice\":\n            self.pub(0)\n\n    def pub(self, nr):\n        self.pub_q.put_nowait(nr)\n\n    async def sub(self):\n        \"\"\"handle incoming messages\"\"\"\n\n        while True:\n            nr = await self.sub_q.get()\n\n            if nr &gt; STOP_AFTER:\n                print(f\"{self.name} had enough. Stopping.\")\n                raise TestComplete\n\n            self.sub_q.task_done()\n            self.pub(nr + 1)\n</code></pre> <p>Let's compare it with a C++ snippets (split over <code>.hpp</code> and <code>.cpp</code> files) to achieve the same functionality...</p> <p>Note</p> <p>I haven't used C++ much since my masters thesis in 2004. So \"Pardon my C++\" ;-). This is what I managed to build with help of ChatGPT.</p> <pre><code>// ----------------- .hpp -----------------------\n#ifndef ROS_BENCHMARK_CPP__ECHO_NODE_HPP_\n#define ROS_BENCHMARK_CPP__ECHO_NODE_HPP_\n\n#include \"rclcpp/rclcpp.hpp\"\n#include \"std_msgs/msg/int64.hpp\"\n#include &lt;chrono&gt;\n\nclass EchoNode : public rclcpp::Node {\npublic:\n    static constexpr int STOP_AFTER = 10'000;\n    EchoNode(const std::string &amp; name, const std::string &amp; sub_topic, const std::string &amp; pub_topic);\n    void pub(int nr);\n\n    // Method to get the start time of the node\n    const std::chrono::steady_clock::time_point&amp; get_start_time() const;\n\nprivate:\n    void sub_callback(const std_msgs::msg::Int64::SharedPtr msg);\n\n    rclcpp::Publisher&lt;std_msgs::msg::Int64&gt;::SharedPtr publisher_;\n    rclcpp::Subscription&lt;std_msgs::msg::Int64&gt;::SharedPtr subscriber_;\n\n    // Start time for the benchmark\n    std::chrono::steady_clock::time_point start_time_;\n\n\n};\n\n#endif  // ROS_BENCHMARK_CPP__ECHO_NODE_HPP_\n\n// ------------------ .cpp -----------------------------\n\n\n#include \"ros_benchmark_cpp/echo_node.hpp\"\n#include &lt;iostream&gt;\n\nEchoNode::EchoNode(const std::string &amp; name, const std::string &amp; sub_topic, const std::string &amp; pub_topic)\n: Node(name),\n  publisher_(this-&gt;create_publisher&lt;std_msgs::msg::Int64&gt;(pub_topic, 10)),\n  subscriber_(this-&gt;create_subscription&lt;std_msgs::msg::Int64&gt;(\n      sub_topic, 10, [this](const std_msgs::msg::Int64::SharedPtr msg) { this-&gt;sub_callback(msg); })),\n  start_time_(std::chrono::steady_clock::now())\n{\n}\n\nvoid EchoNode::sub_callback(const std_msgs::msg::Int64::SharedPtr msg) {\n    int nr = msg-&gt;data;\n\n    if (nr &gt; STOP_AFTER) {\n        std::cout &lt;&lt; this-&gt;get_name() &lt;&lt; \" had enough. Stopping.\" &lt;&lt; std::endl;\n        rclcpp::shutdown();\n    } else {\n        this-&gt;pub(nr + 1);\n    }\n}\n\nvoid EchoNode::pub(int nr) {\n    auto message = std_msgs::msg::Int64();\n    message.data = nr;\n    publisher_-&gt;publish(message);\n}\n\nconst std::chrono::steady_clock::time_point&amp; EchoNode::get_start_time() const {\n    return start_time_;\n}\n</code></pre> <p>Regarding maintainability and readability, I don't have to explain much here - the code speaks for itself.</p>"},{"location":"blog/2023/12/13/why-asyncio-is-ideal-for-robotics-development/#looking-forward","title":"Looking Forward","text":"<p>Interested?</p> <p>Are you passionate about robotics and Python, dreaming of a \"Pythonic ROS\"? You're not alone! I'm on a quest to develop Roxbot, and I'd love to collaborate with like-minded developers.</p>"},{"location":"blog/2023/12/22/effortlessly-add-a-heartbeat-and-power-button-to-your-raspberry-pi/","title":"Effortlessly Add a Heartbeat and Power Button to Your Raspberry Pi","text":"<p>Want to make your Raspberry Pi experience even better with a visible heartbeat and easy shutdown? It's simpler than you think and doesn't even require any software!.</p> <p>Just connect an LED to GPIO 4 and a momentary push button between GPIO 3 and a ground pin.</p> <p>Next, tweak your <code>config.txt</code> by adding these two lines:</p> <pre><code>dtoverlay=gpio-led,gpio=4,label=heartbeat-led,trigger=heartbeat\ndtoverlay=gpio-shutdown,gpio_pin=3,active_low=1,gpio_pull=up\n</code></pre> <p>This setup will give you a pulsating heartbeat indicator and a convenient power button.</p> <p>Reboot your Pi, and voil\u00e0! Your Raspberry Pi now has a handy power button and a cool heartbeat indicator, making it more user-friendly, especially for headless operations.</p>"},{"location":"blog/2024/05/01/repository-structure/","title":"Repository structure","text":"<p>As Aristotle famously said, \"Well begun is half done.\" This is particularly true when starting a new software project. In this post, I'll explain why Continuous Integration (CI) is crucial in modern software development, especially in complex fields like robotics. We'll also look at how CI/CD principles are implemented in the <code>roxbot</code> repository, providing practical insights and inviting you to explore the repository's code for more details.</p>"},{"location":"blog/2024/05/01/repository-structure/#why-is-ci-crucial","title":"Why Is CI Crucial?","text":"<p>Setting up a CI/CD workflow can be daunting, especially in robotics. Homer Simpson humorously said, \"If something is hard to do, then maybe it's not worth doing.\" However, adopting this mindset can lead to significant challenges in larger projects, such as inconsistent environments, outdated documentation, and unstable software. Here\u2019s why CI/CD is essential:</p> <ol> <li> <p>Consistent Build and Test Environments: CI/CD standardizes environments across all development stages, crucial in robotics where diverse tools and packages are used.</p> </li> <li> <p>Enhanced Code Quality: CI automates testing to ensure new code integrates well with the existing codebase, catching issues early to prevent real-world problems.</p> </li> <li> <p>Reduced Deployment Risk: Automated tests in production-like environments decrease the likelihood of failures and enhance safety when deploying software.</p> </li> </ol>"},{"location":"blog/2024/05/01/repository-structure/#how-we-implement-cicd-in-roxbot","title":"How We Implement CI/CD in <code>roxbot</code>","text":"<p>Note</p> <p>Setting up CI/CD properly takes effort and time; getting it 'fairly OK' is achievable, but perfecting it requires considerable work. As a developer, I aim to spend most of my time building functionality, not endlessly polishing my CI/CD environment\u2014which could easily become a full-time job. You'll likely find many areas for improvement in <code>roxbot</code>'s CI/CD, as I capped the setup time at 4 hours. In my experience, CI/CD can always be improved, and contributions are welcome!</p> <ul> <li> <p>Docker Environments:</p> <ul> <li>Development Image (<code>dev</code>): Managed via <code>docker/dev/Dockerfile</code>, includes comprehensive tools for development.</li> <li>Continuous Integration Image (<code>ci</code>): Managed via <code>docker/ci/Dockerfile</code>, designed for reliable and clean testing.</li> </ul> </li> <li> <p>GitHub Actions: Automation is managed through actions configured in <code>.github/workflows/build-images.yml</code> for building and hosting the <code>dev</code> image.</p> </li> <li> <p>VSCode DevContainer: Development setup is streamlined using the configuration in <code>.devcontainer/devcontainer.json</code>.</p> </li> <li> <p>Hosting Images on GitHub: Docker images are hosted using GitHub Packages as part of the workflow defined in <code>.github/workflows/build-images.yml</code>.</p> </li> <li> <p>Configuration with <code>pyproject.toml</code>:</p> <ul> <li><code>ruff</code> linter to maintain high code quality and consistency across the project.</li> <li><code>mypy</code> typechecker enhancing code reliability by catching type errors before runtime.</li> <li><code>pytest</code> with coverage reports. See which lines of code escaped the tests.</li> </ul> </li> <li> <p>Task automation with <code>invoke</code>: a modern, pythonic way of scripting. The tasks are defined in <code>tasks.py</code>.  Run <code>invoke --help</code> for more.</p> </li> <li> <p>Building Documentation with MkDocs: Documentation is automatically built and updated using MkDocs, configured in <code>mkdocs.yml</code>.</p> </li> </ul> <p>This toolset not only solves the \"It works on my machine\" problem but also ensures a high level of task automation, saving time for actual software deveopment.</p> <p>Explore the repository to see how these features are implemented and consider integrating them into your own projects.</p> <p>Tip</p> <p>Manually setting up a repository for each new project can take a lot of time and result in many different structures. To aid this, there is an excellent tool called cookiecutter. There are many templates available to set up a repo in less than a minute! One of my own templates that I often use is python-microservice.  Want to go even further? Take a look at  cruft - a tool to update repositories to their templates.</p>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/","title":"Speed up your ROS2 development with a Docker stack","text":"<p>In this post, I'm going to share with you my solution for quickly setting up development and runtime environments around ROS2. If you've ever struggled with incompatible package versions, conflicting OS requirements, or reproducing the exact same setup across multiple machines, then this post is for you. By utilizing a Docker stack, you can bring up a clean development environment in mere minutes, allowing you to focus on developing your robotics applications instead of system management.</p>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/#why-docker","title":"Why Docker?","text":"<p>Docker solves many of the challenges that developers face:</p> <ol> <li> <p>Automated and reproducible system installation: With Docker, you can start with a clean Ubuntu or pre-installed ROS image and build further on that. A Dockerfile serves as a self-documenting recipe for setting up your system step-by-step, eliminating the need for copying and pasting shell commands.</p> </li> <li> <p>Keeping your system clean: Have you ever messed up your system while experimenting? With Docker, you can simply rebuild the container, and you'll have a clean slate again. This ability to isolate your development environment from your host system is incredibly valuable.</p> </li> <li> <p>Isolated development environment: Similar to virtual environments or virtual machines, a Docker container contains only the necessary components, ensuring that your host system remains untouched. This isolation eliminates conflicts and allows for seamless development across different machines.</p> </li> <li> <p>Deployment: With Docker, you can build an image of your ROS2 application and run it on any machine that supports Docker. This portability simplifies the deployment process, as you don't have to worry about differences in system configurations.</p> </li> <li> <p>CI/CD: By utilizing container images, you can leverage the automation tools provided by platforms like GitHub or GitLab for continuous integration and continuous deployment. This allows for streamlined testing and deployment of your robotics applications.</p> </li> </ol>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/#what-you-need","title":"What you need","text":"<p>To get started, you'll need the following:</p> <ol> <li>A Linux host system (Ubuntu 20+ is recommended).</li> <li><code>git</code> for cloning repositories.</li> <li>Docker for running containers (install easily from get.docker.com).</li> <li>Docker-compose for managing multi-container applications (<code>pip install docker-compose</code>).</li> <li>Visual Studio Code and the devcontainers extension.</li> <li>Basic understanding of development inside a container. If you're new to this concept, you can find an excellent explanation here.</li> </ol>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/#lets-get-started","title":"Let's get started","text":"<p>I've created an example repository on GitLab. Let's begin by getting the code:</p> <pre><code>git clone https://gitlab.com/roxautomation/playground/ros-stack.git\ncd ros-stack\n</code></pre> <p>Now, we can start the Docker stack by running <code>docker-compose up</code>. This command launches the containers defined in the <code>docker-compose.yml</code> file, providing a complete ROS2 environment for development and testing.</p> <p>The stack includes the following services:</p> <ul> <li><code>talker</code>: Runs the <code>talker_node.py</code> script, which posts a message on <code>/chatter</code> every 5 seconds.</li> <li><code>rosboard</code>: Runs the rosboard web UI accessible at localhost:8888.</li> <li><code>rosbridge</code>: Provides a way for non-ROS code to interact with the stack through a WebSocket, using the rosbridge protocol.</li> <li><code>devcontainer</code>: A ROS2 container specifically designed for</li> </ul> <p>development.</p> <p>This setup closely resembles what you would run on a production system.</p>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/#working-with-the-stack","title":"Working with the stack","text":"<p>Once the stack is running, you have a couple of options for interacting with the <code>devcontainer</code>:</p> <ol> <li>From the shell: Use the command <code>docker exec -it devcontainer bash</code> to enter a prompt inside the container.</li> <li>From Visual Studio Code: Use the command <code>Devcontainers: Attach to running container</code> to connect to the <code>devcontainer</code>.</li> </ol> <p>Once inside the <code>devcontainer</code>, you can use familiar ROS2 commands like <code>ros2 node list</code>, <code>ros2 topic list</code>, and <code>ros2 topic echo /chatter</code> to interact with the ROS2 stack.</p> <p>Additionally, if the stack is not running, you can easily launch it from within Visual Studio Code:</p> <ol> <li>Open the repository folder in Visual Studio Code.</li> <li>Run the command <code>Devcontainers: Rebuild and reopen in container</code>. This will rebuild the stack and connect to the <code>devcontainer</code>.</li> </ol> <p>This is actually my preferred way of firing up my dev environment.</p>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/#connecting-from-non-ros-systems","title":"Connecting from non-ROS systems","text":"<p>Sometimes, you may need to interact with the ROS system from non-ROS subsystems, such as a web interface or a pure Python script. In such cases, the <code>rosbridge</code> component comes to the rescue. It enables access to the ROS stack through a WebSocket using well-defined JSON messages. You can utilize the <code>roslibpy</code> Python package to communicate with the <code>rosbridge</code> protocol.</p> <p>An example listener utilizing <code>rosbridge</code> is provided in the <code>/workspace/examples/listen.py</code> file.</p>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/#limitations","title":"Limitations","text":"<p>While running ROS in Docker greatly simplifies system management, it's important to be aware of its limitations. One notable limitation is the difficulty of running native GUI applications inside Docker. Although attempts have been made to make graphical tools work from within a container, the results have been limited and hard to reproduce across different host systems. As a workaround, it's recommended to utilize web-based tools like <code>rosboard</code>. This approach not only overcomes the GUI limitation but also enables the execution of graphical interfaces on remote systems.</p>"},{"location":"blog/2023/06/11/speed-up-your-ros2-development-with-a-docker-stack/#conclusion","title":"Conclusion","text":"<p>Using Docker for your ROS2 development can significantly speed up your workflow by providing an automated, reproducible, and isolated environment. By utilizing Docker's containerization technology, you can minimize the time spent on environment setup, package management, and launch system configuration. The ability to deploy your ROS2 applications seamlessly and leverage CI/CD pipelines further enhances your development process. While there are limitations, such as running native GUI applications, Docker remains an invaluable tool for streamlining ROS2 development and ensuring consistency across multiple machines.</p> <p>I would like to extend my gratitude to the Hadabot blog and their code repository at https://github.com/hadabot/hadabot_main/tree/master/docker for providing valuable insights and inspiration. Their resources greatly helped me get started with using Docker for ROS2 development. I encourage you to explore their content for further knowledge in this area.</p> <p>Give the ROS2 Docker stack a try, and experience the benefits firsthand in your robotics projects. Accelerate your development and focus on building amazing robotic applications without the hassle of system management.</p>"},{"location":"blog/2023/12/01/solid-software-design-principles-for-robotics-developers/","title":"Solid Software Design Principles for Robotics Developers","text":"<p>My journey as a robotics developer began during my Physics studies. There was a significant shift from initially writing complex and chaotic code to my current effective use of various software design patterns and practices. This change has been crucial for building scalable and reliable software for autonomous machines. Like many robotics enthusiasts, my journey didn't start with a Computer Science degree; I learned programming through hands-on experience in the field.</p> <p>In this post, I aim to share the key design principles that guide me every day. These principles have enabled me to independently create advanced robotics software, making the entire development process more manageable and efficient.</p> <p>Here are the guiding principles of software development, with the most crucial ones listed first:</p> <ol> <li> <p>KISS (Keep It Simple, Stupid): Embrace simplicity. Avoid over-complicating systems with unnecessary complexities, as this can hinder understanding, maintenance, and scalability.</p> </li> <li> <p>Less Code Equals Fewer Problems: The more code you have, the more bugs, tests, and maintenance it requires. Strive for minimal code to achieve a system that's easier to understand and maintain. This principle complements YAGNI.</p> </li> <li> <p>DRY (Don't Repeat Yourself): Avoid code duplication. Ensure each piece of knowledge or logic exists only once in your codebase, reducing redundancy and simplifying maintenance.</p> </li> <li> <p>YAGNI (You Aren\u2019t Gonna Need It): Guard against over-engineering. Add features only when they're necessary, rather than preemptively implementing \"just in case\" functionalities.</p> </li> <li> <p>Code Modularity: Break down your codebase into smaller, manageable modules or components. Each module should handle a specific functionality, allowing for independent development and testing. Enhancing this approach with containerization technologies like Docker, you can create microservices with clear interfaces and separated subsystems.</p> </li> <li> <p>Principle of Least Astonishment (POLA): Ensure your software acts in predictable and consistent ways. Functions, classes, and modules should do exactly what their names imply, avoiding surprises for users and developers alike.</p> </li> <li> <p>SOLID Principles: These five principles aim to make software design more understandable, flexible, and maintainable:</p> <ul> <li>Single Responsibility Principle (SRP): Each class should have one and only one reason to change, focusing on a single aspect of functionality.</li> <li>Open/Closed Principle (OCP): Design software entities (classes, modules, functions, etc.) to be open for extension but closed for modification.</li> <li>Liskov Substitution Principle (LSP): Objects of a superclass should be replaceable with objects of its subclasses without affecting program correctness.</li> <li>Interface Segregation Principle (ISP): Avoid forcing clients to depend on methods they don't use. Prefer smaller, specific interfaces over large, general-purpose ones.</li> <li>Dependency Inversion Principle (DIP): High-level modules should not depend on low-level modules. Both should rely on abstractions, which, in turn, should not depend on details. Instead, details should depend on abstractions.</li> </ul> </li> </ol> <p>I'll illustrate the use of <code>SOLID</code> principles with a practical toy example:</p> <pre><code>from abc import ABC, abstractmethod\nimport math\n\n\n# Shape (Abstract Base Class) - Demonstrating Liskov Substitution Principle (LSP)\n# Any subclass of Shape can be substituted for Shape.\nclass Shape(ABC):\n    @abstractmethod\n    def area(self):\n        pass\n\n\n# Rectangle class - adhering to Single Responsibility Principle (SRP)\n# Its only responsibility is to handle rectangle-specific logic.\nclass Rectangle(Shape):\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def area(self):\n        return self.width * self.height\n\n\n# Circle class - adhering to SRP\n# Its only responsibility is to handle circle-specific logic.\nclass Circle(Shape):\n    def __init__(self, radius):\n        self.radius = radius\n\n    def area(self):\n        return math.pi * self.radius**2\n\n\n# ShapeRenderer class - Demonstrating Dependency Inversion Principle (DIP)\n# It depends on the abstract Shape class, not on concrete implementations.\nclass ShapeRenderer:\n    def render(self, shape: Shape):\n        # Here we depend on the abstraction (Shape) rather than concrete implementations.\n        print(f\"Rendering a shape with area: {shape.area()}\")\n\n\n# Adding a new shape type, like Triangle, would not require modifying the ShapeRenderer class.\n# This demonstrates the Open/Closed Principle (OCP).\nclass Triangle(Shape):\n    def __init__(self, base, height):\n        self.base = base\n        self.height = height\n\n    def area(self):\n        return 0.5 * self.base * self.height\n\n\n# Client code\nrectangle = Rectangle(5, 3)\ncircle = Circle(2)\ntriangle = Triangle(3, 4)\n\nrenderer = ShapeRenderer()\nrenderer.render(rectangle)  # Works for Rectangle\nrenderer.render(circle)  # Works for Circle\nrenderer.render(triangle)  # Also works for Triangle without modifying the renderer\n</code></pre> <p>...</p> <p>I hope this practical toy example has illuminated how the SOLID principles can be applied in real-world scenarios.</p> <p>Happy coding!</p>"},{"location":"examples/adapters/","title":"Adapters","text":"<p>\"Adapters\" are used for connecting subsystems and as an interface to user interfaces.</p> <p>A <code>Adapter</code> is an abstraction that implements <code>pub/sub</code> paradigm. An <code>Adapter</code> interface is defined by AdapterProtocol</p> <p>For example, we can split a system in two parts - motion and safety. Each subsystem can run stand-alone in its own docker container. <code>pub/sub</code> topics can be used to communicate between the containers over network.</p> <p>Specific backend of a <code>Adapter</code> can vary. Many \"middlewares\" are available, like <code>mqtt</code>, <code>zeromq</code> and others.</p> <pre><code>graph TD\n\n    subgraph motion_subsystem\n        diffdrive_node\n        line_follower_node\n    end\n\n    subgraph safety_subsystem\n        estop_node\n        lidar_node\n    end\n\n    safety_subsystem ---|Adapter|motion_subsystem\n\n\n</code></pre>"},{"location":"examples/adapters/#mqtt-adapter","title":"MQTT Adapter","text":"<p>see also: code reference</p> <p>Example usage (see <code>examples/Adapters</code> folder)</p> <pre><code>\n</code></pre>"},{"location":"examples/adapters/#background-middleware-alternatives","title":"Background - Middleware alternatives","text":"<p>ROS2 currently uses DDS, which is  a source of frustration for many ROS users. Common criticisms include complexity in setup and configuration, especially in networking and node management. The use of DDS (Data Distribution Service) as the default communication middleware has been highlighted as a pain point, with users reporting difficulties in configuring and optimizing network communications ROS Discourse</p> <p>A list of alternatives for DDD has been considered and well-documented.</p> <p>see RMW alternate.pdf</p> <p>Note</p> <p>ROS2 seems to choose Zenoh. It does however not play nice with <code>asyncio</code>. MQTT seems simpler and more stable.</p>"},{"location":"examples/line_follower/","title":"Basic line follower example","text":"<p>Note</p> <p>This example is work-in-progress</p>"},{"location":"examples/line_follower/#planned","title":"Planned","text":"<ul> <li>[ ] demo notebook</li> </ul>"},{"location":"examples/line_follower/#design","title":"Design","text":"<p>Data flow:</p> <pre><code>\ngraph TD\n    controller_node --&gt; |\"(Vl,Vr)\"|diffdrive_node\n    diffdrive_node --&gt; |\"(Sl,Sr)\"| odometry_node\n    odometry_node --&gt;|\"(x,y,phi)\"|controller_node\n</code></pre> <p>The system consists of 3 nodes:</p> <ul> <li>controller - uses  pure pursuit control algorithm to follow a line along x-axis</li> <li>diffdrive - simulates a differential drive robot</li> <li>odometry - keeps track of robot orientation based on dead reckoning</li> </ul> <p>Each node is a class, running its own coroutines.</p> <p>A class diagram would look like this:</p> <pre><code>classDiagram\n\n\nclass Controller {\n    set_ab_line(a,b)\n}\n\nclass Machine{\n\n    get_pose() -&gt; Pose\n    cmd_vel(twist)\n}\n\nclass DiffDrive{\n    set_vel(k)\n    get_pos() -&gt; sl,sr\n}\n\nclass Odometry{\n    update(sl,sr)\n    get_pose() -&gt; Pose\n}\n\nclass Wheel {\n    set_vel(v)\n    get_dst() -&gt;s\n}\n\nController  o-- Machine\nMachine *-- DiffDrive\nDiffDrive *--\"2\"Wheel\nDiffDrive *-- Odometry\n\n</code></pre> <p>Note: we are assuming perfect odometry tracking here. In real world, this is not the case and odometry values are subject to drift. To solve this, sensor fusion techiques are often used like particle filters or Kalman filter.</p>"},{"location":"examples/nodes/","title":"Nodes","text":"<p><code>roxbot.Node</code> base class provides the boilerplate code to create system nodes.</p>"},{"location":"examples/nodes/#example-usage","title":"Example usage","text":"<pre><code>#!/usr/bin/env python3\n\"\"\"\nNodes example\n--------------\n\nThis example demonstrates how to use the Node class.\n\n* create two nodes that communicate with each other over mqtt.\n* log messages to mqtt with MqttLogger\n\nCopyright (c) 2024 ROX Automation - Jev Kuznetsov\n\"\"\"\n\nimport asyncio\nimport logging\n\nfrom roxbot import Node\nfrom roxbot.adapters import MqttLogger\nfrom roxbot.utils import run_main_async\n\n\nclass NodeOne(Node):\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n        # add coroutines to run in main()\n        self._coros.append(self.talker_coro)\n\n    async def _async_init(self) -&gt; None:\n        \"\"\"init coroutine to run in main()\"\"\"\n        self._log.info(\"Running init coroutine\")\n        await self.mqtt.register_callback(\"/test_cmd\", self.listener_cbk)\n\n    def listener_cbk(self, args: list | dict) -&gt; None:\n        \"\"\"example callback function\"\"\"\n        self._log.info(f\"Running callback with {args=}\")\n\n    async def talker_coro(self) -&gt; None:\n        \"\"\"example coroutine\"\"\"\n\n        counter = 0\n\n        while True:\n            self._log.debug(f\"debug message {counter=}\")\n            self._log.info(f\"info message {counter=}\")\n            counter += 1\n            await asyncio.sleep(1)\n\n\nclass NodeTwo(Node):\n    \"\"\"second node, sends commands to the first\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self._coros.append(self.send_command)  # don't forget this one\n\n    async def send_command(self) -&gt; None:\n        \"\"\"send command to the first node\"\"\"\n        counter = 0\n        while True:\n            await self.mqtt.publish(\"/test_cmd\", {\"counter\": counter})\n            counter += 1\n            await asyncio.sleep(2)\n\n\n# --- main ---\n\n\nasync def main() -&gt; None:\n    mqtt_logger = MqttLogger(logging.getLogger())  # forward logs to mqtt\n    _ = asyncio.create_task(mqtt_logger.main())  # start logging task\n\n    nodes = [NodeOne(), NodeTwo()]\n\n    await asyncio.gather(*[node.main() for node in nodes])\n\n\nif __name__ == \"__main__\":\n    run_main_async(main())\n</code></pre>"},{"location":"reference/adapters/","title":"Adapters","text":""},{"location":"reference/adapters/#mqtt","title":"MQTT","text":"<p>MQTT bridge for communication between subsystems</p> <p>This class class abstracts away specific mqtt implementation</p> <p>Copyright (c) 2024 ROX Automation - Jev Kuznetsov</p>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter","title":"<code>MqttAdapter</code>","text":"<p>MQTT bridge for communication between subsystems</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>class MqttAdapter:\n    \"\"\"MQTT bridge for communication between subsystems\"\"\"\n\n    def __init__(self, config: MqttConfig | None = None) -&gt; None:\n        self._log = logging.getLogger(self.__class__.__name__)\n        self._topic_callbacks: Dict[str, Callable] = {}  # topic callbacks\n\n        self.config = config or MqttConfig()\n\n        self._client: mqtt.Client | None = None\n        self._client_ready = asyncio.Event()\n\n        self._mqtt_queue: asyncio.Queue[MqttMessage] = asyncio.Queue(10)\n\n    async def _publish_mqtt(self, client: mqtt.Client) -&gt; None:\n        \"\"\"publish items from mqtt queue.\n        an item must have .mqtt_message() and .mqtt_topic() methods\"\"\"\n\n        while True:\n            item = await self._mqtt_queue.get()\n            msg = item.message\n            topic = item.topic\n\n            # publish message\n            self._log.debug(f\"{topic=}, {msg=}\")\n            await client.publish(topic, msg.encode() if isinstance(msg, str) else msg)\n            self._mqtt_queue.task_done()\n\n    async def _receive_mqtt(self, client: mqtt.Client) -&gt; None:\n        \"\"\"receive velocity setpoint from mqtt\"\"\"\n\n        self._log.debug(\"Starting mqtt receive loop\")\n        async for message in client.messages:\n            try:\n                self._log.debug(f\"{message.topic=}, {message.payload=}\")\n                if not isinstance(message.payload, (str, bytes, bytearray)):\n                    raise TypeError(f\"Unexpected payload type {type(message.payload)}\")\n\n                topic = message.topic.value\n\n                data = orjson.loads(message.payload)\n                if topic in self._topic_callbacks:\n                    self._topic_callbacks[topic](data)\n\n            except (TypeError, orjson.JSONDecodeError) as e:\n                self._log.error(f\"Error decoding message {message.payload!r}: {e}\")\n\n            except Exception as e:\n                self._log.exception(e, exc_info=True)\n\n    async def register_callback(self, topic: str, fcn: Callable) -&gt; None:\n        \"\"\"add callback to topic.\"\"\"\n        if topic in self._topic_callbacks:\n            raise ValueError(f\"Topic {topic} already has a callback registered\")\n\n        await self.subscribe(topic)\n\n        self._topic_callbacks[topic] = fcn\n\n    async def remove_callback(self, topic: str) -&gt; None:\n        \"\"\"remove topic callback\"\"\"\n        del self._topic_callbacks[topic]\n        await self.unsubscribe(topic)\n\n    async def send(self, topic: str, data: JsonSerializableType) -&gt; None:\n        \"\"\"send data to topic, deprecated\"\"\"\n        warnings.warn(\"send is deprecated, use publish instead\", DeprecationWarning)\n        await self.publish(topic, data)\n\n    async def publish(self, topic: str, data: JsonSerializableType) -&gt; None:\n        \"\"\"publish data to topic\"\"\"\n        await self._mqtt_queue.put(MqttMessage(topic, orjson.dumps(data)))\n\n    async def subscribe(self, topic: str) -&gt; None:\n        \"\"\"subscribe to topic\"\"\"\n\n        await asyncio.wait_for(self._client_ready.wait(), timeout=1)\n\n        if self._client is None:\n            raise RuntimeError(\"MQTT client not initialized\")\n\n        self._log.info(f\"Subscribing to {topic}\")\n        await self._client.subscribe(topic)\n\n    async def unsubscribe(self, topic: str) -&gt; None:\n        \"\"\"unsubscribe from topic\"\"\"\n        if self._client is None:\n            raise RuntimeError(\"MQTT client not initialized\")\n\n        self._log.info(f\"Unsubscribing from {topic}\")\n        await self._client.unsubscribe(topic)\n\n    async def main(self) -&gt; None:\n        \"\"\"starting point to handle mqtt communication, starts send and recieve coroutines\"\"\"\n\n        self._log.info(f\"Connecting to {self.config.host}:{self.config.port}\")\n\n        async with mqtt.Client(self.config.host, port=self.config.port) as client:\n            self._client = client\n            self._client_ready.set()\n            async with asyncio.TaskGroup() as tg:\n                tg.create_task(self._receive_mqtt(client))\n                tg.create_task(self._publish_mqtt(client))\n\n        self._client = None\n</code></pre>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter.main","title":"<code>main()</code>  <code>async</code>","text":"<p>starting point to handle mqtt communication, starts send and recieve coroutines</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>async def main(self) -&gt; None:\n    \"\"\"starting point to handle mqtt communication, starts send and recieve coroutines\"\"\"\n\n    self._log.info(f\"Connecting to {self.config.host}:{self.config.port}\")\n\n    async with mqtt.Client(self.config.host, port=self.config.port) as client:\n        self._client = client\n        self._client_ready.set()\n        async with asyncio.TaskGroup() as tg:\n            tg.create_task(self._receive_mqtt(client))\n            tg.create_task(self._publish_mqtt(client))\n\n    self._client = None\n</code></pre>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter.publish","title":"<code>publish(topic, data)</code>  <code>async</code>","text":"<p>publish data to topic</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>async def publish(self, topic: str, data: JsonSerializableType) -&gt; None:\n    \"\"\"publish data to topic\"\"\"\n    await self._mqtt_queue.put(MqttMessage(topic, orjson.dumps(data)))\n</code></pre>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter.register_callback","title":"<code>register_callback(topic, fcn)</code>  <code>async</code>","text":"<p>add callback to topic.</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>async def register_callback(self, topic: str, fcn: Callable) -&gt; None:\n    \"\"\"add callback to topic.\"\"\"\n    if topic in self._topic_callbacks:\n        raise ValueError(f\"Topic {topic} already has a callback registered\")\n\n    await self.subscribe(topic)\n\n    self._topic_callbacks[topic] = fcn\n</code></pre>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter.remove_callback","title":"<code>remove_callback(topic)</code>  <code>async</code>","text":"<p>remove topic callback</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>async def remove_callback(self, topic: str) -&gt; None:\n    \"\"\"remove topic callback\"\"\"\n    del self._topic_callbacks[topic]\n    await self.unsubscribe(topic)\n</code></pre>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter.send","title":"<code>send(topic, data)</code>  <code>async</code>","text":"<p>send data to topic, deprecated</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>async def send(self, topic: str, data: JsonSerializableType) -&gt; None:\n    \"\"\"send data to topic, deprecated\"\"\"\n    warnings.warn(\"send is deprecated, use publish instead\", DeprecationWarning)\n    await self.publish(topic, data)\n</code></pre>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter.subscribe","title":"<code>subscribe(topic)</code>  <code>async</code>","text":"<p>subscribe to topic</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>async def subscribe(self, topic: str) -&gt; None:\n    \"\"\"subscribe to topic\"\"\"\n\n    await asyncio.wait_for(self._client_ready.wait(), timeout=1)\n\n    if self._client is None:\n        raise RuntimeError(\"MQTT client not initialized\")\n\n    self._log.info(f\"Subscribing to {topic}\")\n    await self._client.subscribe(topic)\n</code></pre>"},{"location":"reference/adapters/#roxbot.adapters.mqtt_adapter.MqttAdapter.unsubscribe","title":"<code>unsubscribe(topic)</code>  <code>async</code>","text":"<p>unsubscribe from topic</p> Source code in <code>roxbot/adapters/mqtt_adapter.py</code> <pre><code>async def unsubscribe(self, topic: str) -&gt; None:\n    \"\"\"unsubscribe from topic\"\"\"\n    if self._client is None:\n        raise RuntimeError(\"MQTT client not initialized\")\n\n    self._log.info(f\"Unsubscribing from {topic}\")\n    await self._client.unsubscribe(topic)\n</code></pre>"},{"location":"reference/interfaces/","title":"Interfaces","text":"<p>Common interface definitions</p>"},{"location":"reference/interfaces/#roxbot.interfaces.AdapterProtocol","title":"<code>AdapterProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>interface for communication bridge</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>class AdapterProtocol(Protocol):\n    \"\"\"interface for communication bridge\"\"\"\n\n    async def publish(self, topic: str, msg: JsonSerializableType) -&gt; None:\n        \"\"\"send a message to a topic\"\"\"\n\n    async def register_callback(self, topic: str, callback: Callable) -&gt; None:\n        \"\"\"register a callback for a topic, subscribe to topic if required\"\"\"\n\n    async def remove_callback(self, topic: str) -&gt; None:\n        \"\"\"remove callback for a topic and unsubscribe if required\"\"\"\n\n    async def main(self) -&gt; None:\n        \"\"\"main loop for the bridge\"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.AdapterProtocol.main","title":"<code>main()</code>  <code>async</code>","text":"<p>main loop for the bridge</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>async def main(self) -&gt; None:\n    \"\"\"main loop for the bridge\"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.AdapterProtocol.publish","title":"<code>publish(topic, msg)</code>  <code>async</code>","text":"<p>send a message to a topic</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>async def publish(self, topic: str, msg: JsonSerializableType) -&gt; None:\n    \"\"\"send a message to a topic\"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.AdapterProtocol.register_callback","title":"<code>register_callback(topic, callback)</code>  <code>async</code>","text":"<p>register a callback for a topic, subscribe to topic if required</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>async def register_callback(self, topic: str, callback: Callable) -&gt; None:\n    \"\"\"register a callback for a topic, subscribe to topic if required\"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.AdapterProtocol.remove_callback","title":"<code>remove_callback(topic)</code>  <code>async</code>","text":"<p>remove callback for a topic and unsubscribe if required</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>async def remove_callback(self, topic: str) -&gt; None:\n    \"\"\"remove callback for a topic and unsubscribe if required\"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.HeadingData","title":"<code>HeadingData</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>heading data</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>class HeadingData(NamedTuple):\n    \"\"\"heading data\"\"\"\n\n    heading: float\n    heading_stdev: float\n    theta: float\n    ts: float\n\n    def to_dict(self) -&gt; dict:\n        return self._asdict()  # type: ignore # pylint: disable=no-member\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.MachineProtocol","title":"<code>MachineProtocol</code>","text":"<p>               Bases: <code>Protocol</code></p> <p>generic machine interface, provides a uniform interface for different machine types such as trikes, differential drives, etc.</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>class MachineProtocol(Protocol):\n    \"\"\"generic machine interface, provides a uniform interface for\n    different machine types such as trikes, differential drives, etc.\"\"\"\n\n    def get_pose(self) -&gt; Pose:\n        \"\"\"return current pose (x, y, theta), in meters.\n        Pose class provides a method for converting to GPS coordinates.\"\"\"\n\n    def cmd_vel(self, linear_velocity: float, angular_velocity: float) -&gt; None:\n        \"\"\"send velocity commands to the machine\"\"\"\n\n    def cmd_curvature(self, v_linear: float, curvature: float) -&gt; None:\n        \"\"\"motion command by curvature\n\n        Args:\n            v_linear (float): driving velocity\n            curvature (float): driving curvature (1/radius)\n        \"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.MachineProtocol.cmd_curvature","title":"<code>cmd_curvature(v_linear, curvature)</code>","text":"<p>motion command by curvature</p> <p>Parameters:</p> Name Type Description Default <code>v_linear</code> <code>float</code> <p>driving velocity</p> required <code>curvature</code> <code>float</code> <p>driving curvature (1/radius)</p> required Source code in <code>roxbot/interfaces.py</code> <pre><code>def cmd_curvature(self, v_linear: float, curvature: float) -&gt; None:\n    \"\"\"motion command by curvature\n\n    Args:\n        v_linear (float): driving velocity\n        curvature (float): driving curvature (1/radius)\n    \"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.MachineProtocol.cmd_vel","title":"<code>cmd_vel(linear_velocity, angular_velocity)</code>","text":"<p>send velocity commands to the machine</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>def cmd_vel(self, linear_velocity: float, angular_velocity: float) -&gt; None:\n    \"\"\"send velocity commands to the machine\"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.MachineProtocol.get_pose","title":"<code>get_pose()</code>","text":"<p>return current pose (x, y, theta), in meters. Pose class provides a method for converting to GPS coordinates.</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>def get_pose(self) -&gt; Pose:\n    \"\"\"return current pose (x, y, theta), in meters.\n    Pose class provides a method for converting to GPS coordinates.\"\"\"\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.Pose","title":"<code>Pose</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>Represents a pose in 2D space</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>class Pose(NamedTuple):\n    \"\"\"Represents a pose in 2D space\"\"\"\n\n    x: float = 0.0\n    y: float = 0.0\n    theta: float = 0.0\n\n    @property\n    def xy(self) -&gt; Vector:\n        return Vector(self.x, self.y)\n</code></pre>"},{"location":"reference/interfaces/#roxbot.interfaces.PositionData","title":"<code>PositionData</code>","text":"<p>               Bases: <code>NamedTuple</code></p> <p>latitude and longitude data</p> Source code in <code>roxbot/interfaces.py</code> <pre><code>class PositionData(NamedTuple):\n    \"\"\"latitude and longitude data\"\"\"\n\n    lat: float\n    lon: float\n    x: float\n    y: float\n    gps_qual: int\n    time: str\n    ts: float  # system time (epoch)\n\n    def to_dict(self) -&gt; dict:\n        return self._asdict()  # type: ignore # pylint: disable=no-member\n</code></pre>"},{"location":"blog/archive/2024/","title":"2024","text":""},{"location":"blog/archive/2023/","title":"2023","text":""},{"location":"blog/category/cicd/","title":"cicd","text":""},{"location":"blog/category/rpi/","title":"rpi","text":""},{"location":"blog/category/hardware/","title":"hardware","text":""},{"location":"blog/category/ros2/","title":"ROS2","text":""},{"location":"blog/category/asyncio/","title":"asyncio","text":""},{"location":"blog/category/dev-tips/","title":"dev-tips","text":""}]}